#version 450
#define EPSILON 0.001

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct Point {
    vec3 point;
};

struct Triangle {
    vec3 p1;
    vec3 p2;
    vec3 p3;
};

layout(set = 0, binding = 0) readonly buffer Triangles {
    Triangle tri[];
} tris;

layout(set = 0, binding = 1) buffer Points {
    Point point[];
} points;

bool ray_tri_intersect(in vec3 O, in Triangle tri, out float hit) {
    // hard code the direction as casting up
    vec3 D = vec3(0,0,1);
    vec3 e1 = tri.p2 - tri.p1; 
    vec3 e2 = tri.p3 - tri.p1; 
    vec3 P = cross(D, e2);
    float det = dot(e1, P); 
    if(det > -EPSILON && det < EPSILON) return false; 
    float inv_det = 1.0 / det; 
    vec3 T = O - tri.p1; 
    float u = dot(T, P) * inv_det; 
    if(u < 0 || u > 1) return false; 
    vec3 Q = cross(T, e1); 
    float v = dot(D, Q) * inv_det; 
    if(v < 0 || u + v  > 1) return false; 
    float t = dot(e2, Q) * inv_det;
    if (t > EPSILON) {
        hit = O[2] + t * D[2];
        return true;
    }
    return false;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;
    if (idx <= tris.tri.length() && idy <= points.point.length()){
        float hit = 0;
        // check if the current point in the tool intersects
        bool intersection = ray_tri_intersect(points.point[idy].point, tris.tri[idx], hit);
        // if Z is higher write it as the current Z
        if (intersection && hit > points.point[idy].point[2]) {
            points.point[idy].point[2] = hit;
        }
    }
}